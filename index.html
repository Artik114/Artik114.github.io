<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>VR Sculpt — Teleport ready</title>
<style>
  body{margin:0;overflow:hidden;background:#111}
  #info{position:absolute;left:10px;top:10px;color:#fff;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px;font-family:sans-serif;z-index:5}
  button{margin-left:8px}
</style>
</head>
<body>
<div id="info">
  A = toggle tool · Trigger (R) = sculpt · Trigger (L) = teleport · Stick R up/down = brush size · Export OBJ<br/>
  <button id="exportBtn">Export OBJ</button>
  <span id="msg" style="margin-left:10px"></span>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/webxr/XRControllerModelFactory.js';
import { OBJExporter } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/exporters/OBJExporter.js';

// Scene & renderer
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x20232a);
const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 1000);
camera.position.set(0,1.6,1.5); // preview pos when not in XR

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType('local');
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

// XR rig (move this group to teleport)
const xrRig = new THREE.Group();
xrRig.add(camera);
scene.add(xrRig);

// Lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x444466, 1.2));
const dir = new THREE.DirectionalLight(0xffffff, 0.6);
dir.position.set(1,2,1);
scene.add(dir);

// Чорна платформа під ногами
const platform = new THREE.Mesh(
  new THREE.CircleGeometry(1.5, 64),
  new THREE.MeshStandardMaterial({ color: 0x000000 })
);
platform.rotation.x = -Math.PI / 2;
platform.position.y = 0;
scene.add(platform);

// Floor (для телепорту)
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(10,10),
  new THREE.MeshStandardMaterial({ color:0x111216 })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Sculpt mesh (сфера) прямо перед очима
let geom = new THREE.SphereGeometry(0.32, 64, 64);
geom = geom.toNonIndexed();
geom.computeVertexNormals();
const mat = new THREE.MeshStandardMaterial({ color:0xdadada, metalness:0.02, roughness:0.6 });
const sculpt = new THREE.Mesh(geom, mat);
sculpt.position.set(0, 1.5, -0.5);
scene.add(sculpt);

// Початкова позиція XR rig
xrRig.position.set(0, 0, 0);

// cache positions
const posAttr = geom.attributes.position;
const normAttr = geom.attributes.normal;
const vertexCount = posAttr.count;
const vertexPositions = new Array(vertexCount);
for (let i=0;i<vertexCount;i++){
  vertexPositions[i] = new THREE.Vector3().fromBufferAttribute(posAttr,i);
}

// build neighbors
const neighbors = new Array(vertexCount);
for (let i=0;i<vertexCount;i++) neighbors[i] = new Set();
for (let i=0;i<vertexCount;i+=3){
  const a=i, b=i+1, c=i+2;
  neighbors[a].add(b); neighbors[a].add(c);
  neighbors[b].add(a); neighbors[b].add(c);
  neighbors[c].add(a); neighbors[c].add(b);
}

// Brush + HUD
let tool = 'Inflate';
let brushRadius = 0.05;
let brushStrength = 0.02;

const brushGeo = new THREE.SphereGeometry(1, 16, 12);
const brushMat = new THREE.MeshStandardMaterial({ color:0x00ff88, transparent:true, opacity:0.25, depthTest:false });
const brushMesh = new THREE.Mesh(brushGeo, brushMat);
scene.add(brushMesh);

// HUD
const hudCanvas = document.createElement('canvas');
hudCanvas.width = 512; hudCanvas.height = 256;
const hudCtx = hudCanvas.getContext('2d');
function drawHUD(){
  hudCtx.clearRect(0,0,hudCanvas.width,hudCanvas.height);
  hudCtx.fillStyle = 'rgba(20,20,20,0.85)'; hudCtx.fillRect(0,0,hudCanvas.width,hudCanvas.height);
  hudCtx.fillStyle = '#fff'; hudCtx.font = '48px sans-serif';
  hudCtx.fillText('Tool: ' + tool, 24, 80);
  hudCtx.fillText('Radius: ' + brushRadius.toFixed(3), 24, 160);
}
drawHUD();
const hudTexture = new THREE.CanvasTexture(hudCanvas);
const hudMat = new THREE.MeshBasicMaterial({ map: hudTexture, side: THREE.DoubleSide, transparent:true });
const hudPlane = new THREE.Mesh(new THREE.PlaneGeometry(0.28, 0.14), hudMat);
hudPlane.renderOrder = 999;

// Controllers
const controllerL = renderer.xr.getController(0);
const controllerR = renderer.xr.getController(1);
xrRig.add(controllerL);
xrRig.add(controllerR);

const gripL = renderer.xr.getControllerGrip(0);
const gripR = renderer.xr.getControllerGrip(1);
const controllerModelFactory = new XRControllerModelFactory();
gripL.add(controllerModelFactory.createControllerModel(gripL));
gripR.add(controllerModelFactory.createControllerModel(gripR));
xrRig.add(gripL);
xrRig.add(gripR);

hudPlane.position.set(0.06, -0.02, 0.04);
hudPlane.rotation.x = -0.2;
gripL.add(hudPlane);

const tip = new THREE.Mesh(new THREE.SphereGeometry(0.01,8,8), new THREE.MeshBasicMaterial({color:0xffaa00}));
controllerR.add(tip);

// Teleport marker
const teleMarker = new THREE.Mesh(
  new THREE.CircleGeometry(0.15, 32),
  new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent:true, opacity:0.5 })
);
teleMarker.rotation.x = -Math.PI/2;
teleMarker.visible = false;
scene.add(teleMarker);

let teleportActive = false;
let lastToggle = 0;
let applying = false;
controllerR.addEventListener('selectstart', ()=>{ applying = true; });
controllerR.addEventListener('selectend', ()=>{ applying = false; });
controllerL.addEventListener('selectstart', ()=>{ teleportActive = true; teleMarker.visible = false; });
controllerL.addEventListener('selectend', ()=>{
  teleportActive = false;
  if (teleMarker.visible) {
    const headWorld = new THREE.Vector3();
    camera.getWorldPosition(headWorld);
    const desiredHead = teleMarker.position.clone().add(new THREE.Vector3(0, 1.6, 0));
    const offset = headWorld.clone().sub(xrRig.position);
    const newRigPos = desiredHead.clone().sub(offset);
    xrRig.position.copy(newRigPos);
  }
  teleMarker.visible = false;
});

const localCenter = new THREE.Vector3();
function applyInflate(worldPos) {
  sculpt.worldToLocal(localCenter.copy(worldPos));
  for (let i=0;i<vertexCount;i++){
    const v = vertexPositions[i];
    const dist = v.distanceTo(localCenter);
    if (dist < brushRadius){
      const t = 1 - dist/brushRadius;
      const dir = v.clone().sub(localCenter).normalize();
      v.add(dir.multiplyScalar(brushStrength * t));
      posAttr.setXYZ(i, v.x, v.y, v.z);
    }
  }
  posAttr.needsUpdate = true;
  geom.computeVertexNormals();
}

function applySmooth(worldPos) {
  sculpt.worldToLocal(localCenter.copy(worldPos));
  const newPos = {};
  for (let i=0;i<vertexCount;i++){
    const v = vertexPositions[i];
    const dist = v.distanceTo(localCenter);
    if (dist < brushRadius){
      let sum = new THREE.Vector3();
      let cnt = 0;
      for (const ni of neighbors[i]){ sum.add(vertexPositions[ni]); cnt++; }
      if (cnt>0){
        sum.multiplyScalar(1/cnt);
        const t = 1 - dist/brushRadius;
        const relax = sum.sub(v).multiplyScalar(0.5 * brushStrength * t * 5);
        newPos[i] = v.clone().add(relax);
      }
    }
  }
  for (const k in newPos){
    vertexPositions[k].copy(newPos[k]);
    posAttr.setXYZ(k, newPos[k].x, newPos[k].y, newPos[k].z);
  }
  posAttr.needsUpdate = true;
  geom.computeVertexNormals();
}

const raycaster = new THREE.Raycaster();
const tempMat = new THREE.Matrix4();
renderer.setAnimationLoop(render);

function render(){
  controllerR.getWorldPosition(brushMesh.position);
  brushMesh.scale.setScalar(brushRadius);
  drawHUD();
  hudTexture.needsUpdate = true;

  const gps = navigator.getGamepads ? navigator.getGamepads() : [];
  for (let i=0;i<gps.length;i++){
    const gp = gps[i];
    if (!gp) continue;
    if (gp.axes && gp.axes.length >= 4){
      const y = gp.axes[3];
      if (Math.abs(y) > 0.2){
        brushRadius = THREE.MathUtils.clamp(brushRadius - y * 0.0025, 0.01, 0.25);
      }
    }
    const now = performance.now();
    const aPressed = (gp.buttons[3] && gp.buttons[3].pressed);
    if (aPressed && now - lastToggle > 300){
      tool = (tool === 'Inflate') ? 'Smooth' : 'Inflate';
      lastToggle = now;
    }
  }

  if (applying){
    const wpos = new THREE.Vector3();
    controllerR.getWorldPosition(wpos);
    if (tool === 'Inflate') applyInflate(wpos);
    else applySmooth(wpos);
    for (let i=0;i<vertexCount;i++){ vertexPositions[i].set(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i)); }
  }

  if (teleportActive){
    tempMat.identity().extractRotation(controllerL.matrixWorld);
    const origin = new THREE.Vector3().setFromMatrixPosition(controllerL.matrixWorld);
    const direction = new THREE.Vector3(0,0,-1).applyMatrix4(tempMat).normalize();
    raycaster.set(origin, direction);
    const hits = raycaster.intersectObject(floor);
    if (hits.length > 0){
      teleMarker.position.copy(hits[0].point);
      teleMarker.visible = true;
    } else teleMarker.visible = false;
  }

  renderer.render(scene, camera);
}

document.getElementById('exportBtn').addEventListener('click', ()=>{
  const exporter = new OBJExporter();
  const str = exporter.parse(sculpt);
  const blob = new Blob([str], {type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'sculpt.obj'; a.click();
  URL.revokeObjectURL(url);
  document.getElementById('msg').textContent = 'OBJ exported';
  setTimeout(()=>document.getElementById('msg').textContent = '', 2500);
});

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
