<!DOCTYPE html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VR Sculpt — Inflate / Smooth / Teleport</title>
<style>
  body{margin:0;overflow:hidden;background:#0e0f11;color:#fff;font-family:Arial,Helvetica,sans-serif}
  #ui { position: absolute; left:10px; top:10px; z-index:10; background: rgba(0,0,0,0.45); padding:10px; border-radius:8px; }
  #ui button { margin-right:8px; }
  #msg { margin-left:8px; color:#aaf; }
</style>
</head>
<body>
<div id="ui">
  A = toggle tool · L trigger = teleport · R trigger = sculpt · R stick up/down = brush size
  <br/>
  <button id="exportBtn">Export OBJ</button><span id="msg"></span>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/webxr/XRControllerModelFactory.js';
import { OBJExporter } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/exporters/OBJExporter.js';

// ---- Config ----
const HEAD_HEIGHT = 1.6;
const START_FORWARD = 0.5; // meters in front of head
// -----------------

// Scene / renderer / camera
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x14161a);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, HEAD_HEIGHT, 0); // local to playerRig

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType('local');
document.body.appendChild(renderer.domElement);

// IMPORTANT: append VRButton after renderer.domElement and xr enabled
document.body.appendChild(VRButton.createButton(renderer));

// Player rig: group we move for teleport (contains camera and controllers)
const playerRig = new THREE.Group();
playerRig.position.set(0, 0, 0); // preview: leaving at origin; in non-XR camera pos = playerRig+camera
playerRig.add(camera);
scene.add(playerRig);

// Lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x444466, 1.1));
const dl = new THREE.DirectionalLight(0xffffff, 0.6);
dl.position.set(1,2,1);
scene.add(dl);

// Black platform under player's feet (attach to playerRig so it's always under)
const platform = new THREE.Mesh(
  new THREE.CircleGeometry(1.2, 64),
  new THREE.MeshStandardMaterial({ color: 0x000000 })
);
platform.rotation.x = -Math.PI/2;
platform.position.set(0, 0, 0);
playerRig.add(platform);

// World floor (for teleport raycast)
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(30, 30),
  new THREE.MeshStandardMaterial({ color: 0x111216 })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Sculpt mesh (sphere) — we'll position it in sessionstart to be in front of head
let sculptGeom = new THREE.SphereGeometry(0.32, 64, 64).toNonIndexed();
sculptGeom.computeVertexNormals();
const sculptMat = new THREE.MeshStandardMaterial({ color: 0xdadada, metalness:0.02, roughness:0.6 });
const sculpt = new THREE.Mesh(sculptGeom, sculptMat);
scene.add(sculpt);

// cache positions and neighbors
const posAttr = sculptGeom.attributes.position;
const vertexCount = posAttr.count;
const vertexPosLocal = new Array(vertexCount);
for (let i=0;i<vertexCount;i++) vertexPosLocal[i] = new THREE.Vector3().fromBufferAttribute(posAttr, i);
const neighbors = new Array(vertexCount);
for (let i=0;i<vertexCount;i++) neighbors[i] = new Set();
for (let i=0;i<vertexCount;i+=3){
  const a=i, b=i+1, c=i+2;
  neighbors[a].add(b); neighbors[a].add(c);
  neighbors[b].add(a); neighbors[b].add(c);
  neighbors[c].add(a); neighbors[c].add(b);
}

// Brush visuals & HUD
let tool = 'Inflate';
let brushRadius = 0.05;
let brushStrength = 0.02;

const brushVisual = new THREE.Mesh(
  new THREE.SphereGeometry(1, 16, 12),
  new THREE.MeshStandardMaterial({ color: 0x00ff88, transparent:true, opacity:0.25, depthTest:false })
);
scene.add(brushVisual);

// HUD: canvas texture attached to left grip
const hudCanvas = document.createElement('canvas');
hudCanvas.width = 512; hudCanvas.height = 256;
const hudCtx = hudCanvas.getContext('2d');
function drawHUD(){
  hudCtx.clearRect(0,0,hudCanvas.width,hudCanvas.height);
  hudCtx.fillStyle = 'rgba(18,18,18,0.9)';
  hudCtx.fillRect(0,0,hudCanvas.width,hudCanvas.height);
  hudCtx.fillStyle = '#fff';
  hudCtx.font = '40px sans-serif';
  hudCtx.fillText('Tool: ' + tool, 20, 70);
  hudCtx.fillText('Radius: ' + brushRadius.toFixed(3), 20, 150);
}
drawHUD();
const hudTex = new THREE.CanvasTexture(hudCanvas);
const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.28, 0.14), new THREE.MeshBasicMaterial({ map: hudTex, side: THREE.DoubleSide, transparent:true }));
hudMesh.renderOrder = 999;

// Controllers & grips
const controllerL = renderer.xr.getController(0);
const controllerR = renderer.xr.getController(1);
playerRig.add(controllerL);
playerRig.add(controllerR);

const gripL = renderer.xr.getControllerGrip(0);
const gripR = renderer.xr.getControllerGrip(1);
const cmf = new XRControllerModelFactory();
gripL.add(cmf.createControllerModel(gripL));
gripR.add(cmf.createControllerModel(gripR));
playerRig.add(gripL);
playerRig.add(gripR);

// attach HUD to left grip
hudMesh.position.set(0.06, -0.02, 0.04);
hudMesh.rotation.x = -0.2;
gripL.add(hudMesh);

// small sphere to mark right controller tip
const tip = new THREE.Mesh(new THREE.SphereGeometry(0.01, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffaa00 }));
controllerR.add(tip);

// Teleport marker
const teleMarker = new THREE.Mesh(new THREE.CircleGeometry(0.15, 32), new THREE.MeshBasicMaterial({ color: 0x00ffcc, transparent:true, opacity:0.6 }));
teleMarker.rotation.x = -Math.PI/2;
teleMarker.visible = false;
scene.add(teleMarker);

// state
let teleportActive = false;
let applying = false;
let lastToggle = 0;

// controller events
controllerR.addEventListener('selectstart', ()=>{ applying = true; });
controllerR.addEventListener('selectend', ()=>{ applying = false; });

controllerL.addEventListener('selectstart', ()=>{ teleportActive = true; teleMarker.visible = false; });
controllerL.addEventListener('selectend', ()=>{
  teleportActive = false;
  if (teleMarker.visible) {
    // move playerRig so head will be at teleMarker + HEAD_HEIGHT
    const headWorld = new THREE.Vector3(); camera.getWorldPosition(headWorld);
    const desiredHead = teleMarker.position.clone().add(new THREE.Vector3(0, HEAD_HEIGHT, 0));
    const offset = headWorld.clone().sub(playerRig.position);
    const newRigPos = desiredHead.clone().sub(offset);
    playerRig.position.copy(newRigPos);
  }
  teleMarker.visible = false;
});

// sculpt application functions
const worldToLocal = new THREE.Vector3();
function applyInflate(worldPos){
  sculpt.worldToLocal(worldToLocal.copy(worldPos));
  for (let i=0;i<vertexCount;i++){
    const v = vertexPosLocal[i];
    const dist = v.distanceTo(worldToLocal);
    if (dist < brushRadius){
      const t = 1 - dist / brushRadius;
      const dir = v.clone().sub(worldToLocal).normalize();
      v.add(dir.multiplyScalar(brushStrength * t));
      posAttr.setXYZ(i, v.x, v.y, v.z);
    }
  }
  posAttr.needsUpdate = true;
  sculptGeom.computeVertexNormals();
}
function applySmooth(worldPos){
  sculpt.worldToLocal(worldToLocal.copy(worldPos));
  const newPos = {};
  for (let i=0;i<vertexCount;i++){
    const v = vertexPosLocal[i];
    const dist = v.distanceTo(worldToLocal);
    if (dist < brushRadius){
      let sum = new THREE.Vector3(); let cnt = 0;
      for (const ni of neighbors[i]){ sum.add(vertexPosLocal[ni]); cnt++; }
      if (cnt > 0){
        sum.multiplyScalar(1 / cnt);
        const t = 1 - dist / brushRadius;
        const relax = sum.sub(v).multiplyScalar(0.5 * brushStrength * t * 5.0);
        newPos[i] = v.clone().add(relax);
      }
    }
  }
  for (const k in newPos){
    vertexPosLocal[k].copy(newPos[k]);
    posAttr.setXYZ(k, newPos[k].x, newPos[k].y, newPos[k].z);
  }
  posAttr.needsUpdate = true;
  sculptGeom.computeVertexNormals();
}

// raycaster for teleport
const raycaster = new THREE.Raycaster();
const tmpPos = new THREE.Vector3();
const tmpQuat = new THREE.Quaternion();
const forward = new THREE.Vector3(0,0,-1);

// animation loop
renderer.setAnimationLoop(animate);
function animate(){
  // Update visual brush position to right controller world position
  controllerR.getWorldPosition(brushVisual.position);
  brushVisual.scale.setScalar(brushRadius);

  // HUD update
  drawHUD(); hudTex.needsUpdate = true;

  // read gamepads for stick & A button
  const gps = navigator.getGamepads ? navigator.getGamepads() : [];
  for (let i=0;i<gps.length;i++){
    const gp = gps[i];
    if (!gp) continue;
    // Right stick vertical common at axes[3]
    let y = 0;
    if (gp.axes && gp.axes.length >= 4) y = gp.axes[3];
    else if (gp.axes && gp.axes.length >= 2 && i === 1) y = gp.axes[1];
    if (Math.abs(y) > 0.2) brushRadius = THREE.MathUtils.clamp(brushRadius - y * 0.0025, 0.01, 0.25);

    // Toggle tool with A (try common indices)
    const now = performance.now();
    const aPressed = (gp.buttons[3] && gp.buttons[3].pressed) || (gp.buttons[0] && gp.buttons[0].pressed && gp.id && gp.id.toLowerCase().includes('oculus'));
    if (aPressed && now - lastToggle > 300){
      tool = (tool === 'Inflate') ? 'Smooth' : 'Inflate';
      lastToggle = now;
    }
  }

  // apply sculpt while right trigger held
  if (applying){
    const w = new THREE.Vector3();
    controllerR.getWorldPosition(w);
    if (tool === 'Inflate') applyInflate(w);
    else applySmooth(w);
    // sync cached positions
    for (let i=0;i<vertexCount;i++) vertexPosLocal[i].set(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
  }

  // teleport raycasting while active
  if (teleportActive){
    controllerL.getWorldPosition(tmpPos);
    controllerL.getWorldQuaternion(tmpQuat);
    const dir = forward.clone().applyQuaternion(tmpQuat).normalize();
    raycaster.set(tmpPos, dir);
    const hits = raycaster.intersectObject(floor);
    if (hits.length > 0){
      teleMarker.position.copy(hits[0].point);
      teleMarker.visible = true;
    } else teleMarker.visible = false;
  }

  renderer.render(scene, camera);
}

// Place sculpt directly in front of head when VR session starts (so it's always visible)
renderer.xr.addEventListener('sessionstart', () => {
  try {
    // get head world position and forward direction
    const xrCam = renderer.xr.getCamera(camera); // returns three.js camera used by XR
    const headPos = new THREE.Vector3(); xrCam.getWorldPosition(headPos);
    // compute forward: camera's -Z in world
    const quat = new THREE.Quaternion(); xrCam.getWorldQuaternion(quat);
    const forwardVec = new THREE.Vector3(0,0,-1).applyQuaternion(quat).normalize();
    // place sculpt START_FORWARD meters ahead, at approx chest height
    const target = headPos.clone().add(forwardVec.multiplyScalar(START_FORWARD));
    sculpt.position.set(target.x, headPos.y - 0.1, target.z);
  } catch(e){
    // fallback to default
    sculpt.position.set(0, HEAD_HEIGHT - 0.1, -START_FORWARD);
  }
});

// Export OBJ (UI button)
const exportBtn = document.getElementById('exportBtn');
const msgEl = document.getElementById('msg');
exportBtn.addEventListener('click', () => {
  const exporter = new OBJExporter();
  const text = exporter.parse(sculpt);
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'sculpt.obj'; a.click();
  URL.revokeObjectURL(url);
  msgEl.textContent = 'OBJ exported';
  setTimeout(()=>msgEl.textContent = '', 2500);
});

// Resize
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Debug helper: log XR availability to console
if (navigator.xr) {
  navigator.xr.isSessionSupported('immersive-vr').then(supported => {
    console.log('WebXR immersive-vr supported:', supported);
  }).catch(e => console.warn('XR check failed', e));
} else {
  console.log('navigator.xr not present — WebXR unavailable in this browser');
}
</script>
</body>
</html>
