<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VR Sculpt — Teleport fix</title>
<style>
  body{margin:0;overflow:hidden;background:#111;font-family:sans-serif}
  #info{position:absolute;left:10px;top:10px;color:#fff;background:rgba(0,0,0,0.5);padding:8px;border-radius:6px;z-index:5}
  button{margin-left:8px}
</style>
</head>
<body>
<div id="info">
  A = toggle tool · L trigger = teleport · R trigger = sculpt · R stick up/down = brush size ·
  <button id="exportBtn">Export OBJ</button>
  <span id="msg" style="margin-left:10px"></span>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/webxr/XRControllerModelFactory.js';
import { OBJExporter } from 'https://cdn.jsdelivr.net/npm/three@0.157/examples/jsm/exporters/OBJExporter.js';

// ---- config ----
const HEAD_HEIGHT = 1.6;      // metres
const INITIAL_RIG_Z = 1.5;    // move rig forward so preview camera sees scene
const START_FORWARD = 0.5;    // how far in front the sculpt will spawn
// -----------------

// Scene + renderer + camera
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x20232a);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, HEAD_HEIGHT, 0); // local to rig

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType('local');
document.body.appendChild(renderer.domElement);

// VR Button (after renderer is on DOM and xr enabled)
document.body.appendChild(VRButton.createButton(renderer));

// xrRig — group we move when teleporting
const xrRig = new THREE.Group();
xrRig.position.set(0, 0, INITIAL_RIG_Z); // preview offset so camera sees scene when not in XR
xrRig.add(camera);
scene.add(xrRig);

// Lighting
scene.add(new THREE.HemisphereLight(0xffffff, 0x444466, 1.2));
const dl = new THREE.DirectionalLight(0xffffff, 0.6);
dl.position.set(1,2,1);
scene.add(dl);

// Platform (black mat) — attach to xrRig so it stays under player
const platform = new THREE.Mesh(
  new THREE.CircleGeometry(1.2, 64),
  new THREE.MeshStandardMaterial({ color: 0x000000 })
);
platform.rotation.x = -Math.PI/2;
platform.position.set(0, 0, 0);
xrRig.add(platform);

// Floor (world) — used for teleport raycast
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(20, 20),
  new THREE.MeshStandardMaterial({ color: 0x111216 })
);
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Sculpt mesh (sphere) — place in world so it's in front of player's start head position
const sculptGeom = new THREE.SphereGeometry(0.32, 64, 64).toNonIndexed();
sculptGeom.computeVertexNormals();
const sculptMat = new THREE.MeshStandardMaterial({ color: 0xdadada, metalness:0.02, roughness:0.6 });
const sculpt = new THREE.Mesh(sculptGeom, sculptMat);

// compute sculpt world position so it is START_FORWARD meters in front of initial camera world pos
// camera world pos = xrRig.position + camera.position
const cameraWorldZ = xrRig.position.z + camera.position.z; // camera.position.z is 0
sculpt.position.set(0, HEAD_HEIGHT - 0.1, cameraWorldZ - START_FORWARD);
scene.add(sculpt);

// --- prepare sculpt arrays & neighbors ---
const posAttr = sculptGeom.attributes.position;
const vertexCount = posAttr.count;
const vertexPosLocal = new Array(vertexCount);
for (let i=0;i<vertexCount;i++) vertexPosLocal[i] = new THREE.Vector3().fromBufferAttribute(posAttr,i);

// build neighbor sets (non-indexed triangles)
const neighbors = new Array(vertexCount);
for (let i=0;i<vertexCount;i++) neighbors[i] = new Set();
for (let i=0; i<vertexCount; i+=3){
  const a=i, b=i+1, c=i+2;
  neighbors[a].add(b); neighbors[a].add(c);
  neighbors[b].add(a); neighbors[b].add(c);
  neighbors[c].add(a); neighbors[c].add(b);
}

// Brush visuals + HUD
let tool = 'Inflate';
let brushRadius = 0.05;
let brushStrength = 0.02;

const brushVisual = new THREE.Mesh(
  new THREE.SphereGeometry(1, 16, 12),
  new THREE.MeshStandardMaterial({ color:0x00ff88, transparent:true, opacity:0.25, depthTest:false })
);
scene.add(brushVisual);

// HUD canvas on left grip
const hudCanvas = document.createElement('canvas');
hudCanvas.width = 512; hudCanvas.height = 256;
const hudCtx = hudCanvas.getContext('2d');
function drawHUD(){
  hudCtx.clearRect(0,0,hudCanvas.width,hudCanvas.height);
  hudCtx.fillStyle = 'rgba(20,20,20,0.85)'; hudCtx.fillRect(0,0,hudCanvas.width,hudCanvas.height);
  hudCtx.fillStyle = '#fff'; hudCtx.font = '44px sans-serif';
  hudCtx.fillText('Tool: ' + tool, 20, 60);
  hudCtx.fillText('Radius: ' + brushRadius.toFixed(3), 20, 140);
}
drawHUD();
const hudTex = new THREE.CanvasTexture(hudCanvas);
const hudMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.28, 0.14), new THREE.MeshBasicMaterial({ map: hudTex, side: THREE.DoubleSide, transparent:true }));
hudMesh.renderOrder = 999;

// Controllers + grips
const controllerL = renderer.xr.getController(0);
const controllerR = renderer.xr.getController(1);
// add controllers as children of xrRig so teleport moves them consistently with rig
xrRig.add(controllerL);
xrRig.add(controllerR);

const gripL = renderer.xr.getControllerGrip(0);
const gripR = renderer.xr.getControllerGrip(1);
const cmf = new XRControllerModelFactory();
gripL.add(cmf.createControllerModel(gripL));
gripR.add(cmf.createControllerModel(gripR));
xrRig.add(gripL);
xrRig.add(gripR);

// attach HUD to left grip (wrist)
hudMesh.position.set(0.06, -0.02, 0.04);
hudMesh.rotation.x = -0.2;
gripL.add(hudMesh);

// right controller tip marker
const tip = new THREE.Mesh(new THREE.SphereGeometry(0.01, 8, 8), new THREE.MeshBasicMaterial({ color:0xffaa00 }));
controllerR.add(tip);

// teleport marker
const teleMarker = new THREE.Mesh(new THREE.CircleGeometry(0.15, 32), new THREE.MeshBasicMaterial({ color:0x00ffcc, transparent:true, opacity:0.6 }));
teleMarker.rotation.x = -Math.PI/2;
teleMarker.visible = false;
scene.add(teleMarker);

// state
let teleportActive = false;
let applying = false;
let lastToggle = 0;

// events
controllerR.addEventListener('selectstart', ()=>{ applying = true; });
controllerR.addEventListener('selectend', ()=>{ applying = false; });

controllerL.addEventListener('selectstart', ()=>{ teleportActive = true; teleMarker.visible = false; });
controllerL.addEventListener('selectend', ()=>{
  teleportActive = false;
  if (teleMarker.visible){
    // move xrRig so camera (head) will be at teleMarker + HEAD_HEIGHT
    const headWorld = new THREE.Vector3(); camera.getWorldPosition(headWorld);
    const desiredHead = teleMarker.position.clone().add(new THREE.Vector3(0, HEAD_HEIGHT, 0));
    const offset = headWorld.clone().sub(xrRig.position);
    const newRig = desiredHead.clone().sub(offset);
    xrRig.position.copy(newRig);
  }
  teleMarker.visible = false;
});

// sculpt apply functions (operate on local vertex array)
const localCenter = new THREE.Vector3();
function applyInflate(worldPos){
  sculpt.worldToLocal(localCenter.copy(worldPos));
  for (let i=0;i<vertexCount;i++){
    const v = vertexPosLocal[i];
    const dist = v.distanceTo(localCenter);
    if (dist < brushRadius){
      const t = 1 - dist/brushRadius;
      const dir = v.clone().sub(localCenter).normalize();
      v.add(dir.multiplyScalar(brushStrength * t));
      posAttr.setXYZ(i, v.x, v.y, v.z);
    }
  }
  posAttr.needsUpdate = true;
  sculptGeom.computeVertexNormals();
}
function applySmooth(worldPos){
  sculpt.worldToLocal(localCenter.copy(worldPos));
  const newPos = {};
  for (let i=0;i<vertexCount;i++){
    const v = vertexPosLocal[i];
    const dist = v.distanceTo(localCenter);
    if (dist < brushRadius){
      let sum = new THREE.Vector3(); let cnt = 0;
      for (const ni of neighbors[i]){ sum.add(vertexPosLocal[ni]); cnt++; }
      if (cnt>0){
        sum.multiplyScalar(1/cnt);
        const t = 1 - dist/brushRadius;
        const relax = sum.sub(v).multiplyScalar(0.5 * brushStrength * t * 5.0);
        newPos[i] = v.clone().add(relax);
      }
    }
  }
  for (const k in newPos){
    vertexPosLocal[k].copy(newPos[k]);
    posAttr.setXYZ(k, newPos[k].x, newPos[k].y, newPos[k].z);
  }
  posAttr.needsUpdate = true;
  sculptGeom.computeVertexNormals();
}

// raycaster helper for teleport
const raycaster = new THREE.Raycaster();
const tmpPos = new THREE.Vector3();
const tmpQuat = new THREE.Quaternion();
const forward = new THREE.Vector3(0,0,-1);

// animation
renderer.setAnimationLoop(animate);
function animate(){
  // update brush visual to right controller world position
  controllerR.getWorldPosition(brushVisual.position);
  brushVisual.scale.setScalar(brushRadius);

  // HUD
  drawHUD();
  hudTex.needsUpdate = true;

  // read gamepads for stick (brush size) and A toggle
  const gps = navigator.getGamepads ? navigator.getGamepads() : [];
  for (let i=0; i<gps.length; i++){
    const gp = gps[i];
    if (!gp) continue;
    // try right stick Y (common mapping axes[3])
    const y = (gp.axes && gp.axes.length >= 4) ? gp.axes[3] : (gp.axes && gp.axes.length >= 2 && i===1 ? gp.axes[1] : 0);
    if (Math.abs(y) > 0.2) brushRadius = THREE.MathUtils.clamp(brushRadius - y * 0.0025, 0.01, 0.25);

    // Toggle tool (A) — many devices map A to buttons[3], fallback check
    const now = performance.now();
    const aPressed = (gp.buttons[3] && gp.buttons[3].pressed) || (gp.buttons[0] && gp.buttons[0].pressed && gp.id && gp.id.toLowerCase().includes('oculus'));
    if (aPressed && now - lastToggle > 300){
      tool = (tool === 'Inflate') ? 'Smooth' : 'Inflate';
      lastToggle = now;
    }
  }

  // apply sculpt while right trigger held
  if (applying){
    const wpos = new THREE.Vector3();
    controllerR.getWorldPosition(wpos);
    if (tool === 'Inflate') applyInflate(wpos);
    else applySmooth(wpos);
    // sync cached array with attribute (posAttr already updated)
    for (let i=0;i<vertexCount;i++) vertexPosLocal[i].set(posAttr.getX(i), posAttr.getY(i), posAttr.getZ(i));
  }

  // teleport raycast while teleportActive
  if (teleportActive){
    controllerL.getWorldPosition(tmpPos);
    controllerL.getWorldQuaternion(tmpQuat);
    const dir = forward.clone().applyQuaternion(tmpQuat).normalize();
    raycaster.set(tmpPos, dir);
    const hits = raycaster.intersectObject(floor);
    if (hits.length > 0){
      teleMarker.position.copy(hits[0].point);
      teleMarker.visible = true;
    } else teleMarker.visible = false;
  }

  renderer.render(scene, camera);
}

// Export OBJ button (UI)
const exportBtn = document.getElementById('exportBtn');
const msg = document.getElementById('msg');
exportBtn.addEventListener('click', ()=>{
  const exporter = new OBJExporter();
  const text = exporter.parse(sculpt);
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'sculpt.obj'; a.click();
  URL.revokeObjectURL(url);
  msg.textContent = 'OBJ exported';
  setTimeout(()=>msg.textContent='', 2000);
});

// resize
window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Debug helper: log xr availability
if (navigator.xr) {
  navigator.xr.isSessionSupported('immersive-vr').then(supported => {
    console.log('WebXR immersive-vr supported:', supported);
  }).catch(e => console.warn('XR check failed', e));
} else {
  console.log('navigator.xr not present — WebXR unavailable in this browser');
}
</script>
</body>
</html>
